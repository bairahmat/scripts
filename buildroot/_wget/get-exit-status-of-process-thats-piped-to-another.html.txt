   Link: canonical

  current community

     * chat
       Unix & Linux
     * Unix & Linux Meta

  your communities

   Sign up or log in to customize your list.

  more stack exchange communities

   company blog
   Stack Exchange Inbox  Reputation and Badges
   sign up log in tour help 
     * Tour Start here for a quick overview of the site
     * Help Center Detailed answers to any questions you might have
     * Meta Discuss the workings and policies of this site
     * About Us Learn more about Stack Overflow the company
     * Business Learn more about hiring developers or posting ads with us
   _____________________
   Unix & Linux
     * Questions
     * Tags
     * Users
     * Badges
     * Unanswered
     * Ask Question
   Link:
   https://cdn.sstatic.net/Sites/unix/img/apple-touch-icon.png?v=5cf7fe716a89
   _
   Unix & Linux Stack Exchange is a question and answer site for users of
   Linux, FreeBSD and other Un*x-like operating systems. Join them; it only
   takes a minute:

   Sign up
   Here's how it works:
    1. Anybody can ask a question
    2. Anybody can answer
    3. The best answers are voted up and rise to the top

               Get exit status of process that's piped to another

                    I have two processes foo and bar, connected with a pipe:  
                                                                              
                    $ foo | bar                                               
                                                                              
                    bar always exits 0; I'm interested in the exit code of    
   up vote 184 down foo. Is there any way to get at it?                       
   vote favorite                                                              
   84               shell pipe exit                                           
                                                                              
                                         edited May 17 '13 asked Jun 2 '11 at 
                    share|improve this            at 17:18 20:19              
                    question                         [IMG] [IMG]              
                                                   lesmana Michael Mrozek♦    
                                                11.8k94566 51.2k20166192      
                         stackoverflow.com/questions/1221833/… – Ciro         
                         Santilli å**æ**æ³¢æ» å*å**äº*ä»¶ æ³*è½®å** Nov 15    
                         '16 at 17:22                                         
                                                                              
                    add a comment |  expand to show all comments on this post 

15 Answers

   active oldest votes

         If you are using bash, you can use the PIPESTATUS array variable to get the    
         exit status of each element of the pipeline.                                   
                                                                                        
         $ false | true                                                                 
         $ echo "${PIPESTATUS[0]} ${PIPESTATUS[1]}"                                     
         1 0                                                                            
                                                                                        
         If you are using zsh, they array is called pipestatus (case matters!) and the  
         array indices start at one:                                                    
                                                                                        
         $ false | true                                                                 
         $ echo "${pipestatus[1]} ${pipestatus[2]}"                                     
         1 0                                                                            
up vote                                                                                 
150 down To combine them within a function in a manner that doesn't lose the values:    
vote                                                                                    
accepted $ false | true                                                                 
         $ retval_bash="${PIPESTATUS[0]}" retval_zsh="${pipestatus[1]}" retval_final=$? 
         $ echo $retval_bash $retval_zsh $retval_final                                  
         1 0                                                                            
                                                                                        
         Run the above in bash or zsh and you'll get the same results; only one of      
         retval_bash and retval_zsh will be set. The other will be blank. This would    
         allow a function to end with return $retval_bash $retval_zsh (note the lack of 
         quotes!).                                                                      
                                                                                        
                                       edited Jan 15 '15 at answered Jun 2 '11 at 20:49 
                                                       2:34                       [IMG] 
         share|improve this answer                    [IMG]                        camh 
                                                  Adam Katz                  19.8k55248 
                                                   1,477616                             
         7   And pipestatus in zsh. Unfortunately other shells don't have this feature. 
             – Gilles Jun 2 '11 at 21:05                                                
         6   Note: Arrays in zsh begin counterintuitively at index 1, so it's echo      
             "$pipestatus[1]" "$pipestatus[2]". – Christoph Wurm Nov 14 '11 at 14:09    
             You could check the whole pipeline like this: if [ `echo                   
         3   "${PIPESTATUS[@]}" | tr -s ' ' + | bc` -ne 0 ]; then echo FAIL; fi – l0b0  
             Sep 25 '12 at 15:39                                                        
             @JanHudec: Perhaps you should read the first five words of my answer. Also 
         4   kindly point out where the question requested a POSIX-only answer. – camh  
             Dec 16 '14 at 8:27                                                         
             @JanHudec: Nor was it tagged POSIX. Why do you assume the answer must be   
         5   POSIX? It was not specified so I provided a qualified answer. There is     
             nothing incorrect about my answer, plus there are multiple answers to      
             address other cases. – camh Dec 17 '14 at 9:15                             
                                                                                        
          |  show 4 more comments                                                       

               There are 3 common ways of doing this:                         
                                                                              
               Pipefail                                                       
                                                                              
               The first way is to set the pipefail option (ksh, zsh or       
               bash). This is the simplest and what it does is basically set  
               the exit status $? to the exit code of the last program to     
               exit non-zero (or zero if all exited successfully).            
                                                                              
               $ false | true; echo $?                                        
               0                                                              
               $ set -o pipefail                                              
               $ false | true; echo $?                                        
               1                                                              
                                                                              
               $PIPESTATUS                                                    
                                                                              
               Bash also has an array variable called $PIPESTATUS             
               ($pipestatus in zsh) which contains the exit status of all the 
               programs in the last pipeline.                                 
                                                                              
               $ true | true; echo "${PIPESTATUS[@]}"                         
               0 0                                                            
               $ false | true; echo "${PIPESTATUS[@]}"                        
   up vote 160 1 0                                                            
   down vote   $ false | true; echo "${PIPESTATUS[0]}"                        
               1                                                              
               $ true | false; echo "${PIPESTATUS[@]}"                        
               0 1                                                            
                                                                              
               You can use the 3rd command example to get the specific value  
               in the pipeline that you need.                                 
                                                                              
               Separate executions                                            
                                                                              
               This is the most unwieldy of the solutions. Run each command   
               separately and capture the status                              
                                                                              
               $ OUTPUT="$(echo foo)"                                         
               $ STATUS_ECHO="$?"                                             
               $ printf '%s' "$OUTPUT" | grep -iq "bar"                       
               $ STATUS_GREP="$?"                                             
               $ echo "$STATUS_ECHO $STATUS_GREP"                             
               0 1                                                            
                                                                              
                                                       answered Apr 21 '13 at 
               share|improve this edited Dec 31 '15                     13:56 
               answer                      at 18:24                     [IMG] 
                                          user79743                   Patrick 
                                                                 40.4k9101143 
               2   Darn! I was just gonna post about PIPESTATUS. – slm♦ Apr   
                   21 '13 at 13:57                                            
                   For reference there are several other techniques discussed 
               1   in this SO question: stackoverflow.com/questions/1221833/… 
                   – slm♦ Apr 21 '13 at 14:00                                 
                   @Patrick the pipestatus solution is works on bash , just   
                   more quastion in case I use ksh script you think we can    
               1   find something similar to pipestatus ? , ( meenwhile I see 
                   the pipestatus not supported by ksh ) – yael Apr 21 '13 at 
                   14:32                                                      
                   @yael I don't use ksh, but from a brief glance at it's     
               1   manpage, it doesn't support $PIPESTATUS or anything        
                   similar. It does support the pipefail option though.       
                   – Patrick Apr 21 '13 at 15:30                              
               1   Great answer. I learned 2 things I never knew. :) – Tim    
                   Kennedy Apr 30 '13 at 19:14                                
                                                                              
                |  show 2 more comments                                       

              While not exactly what you asked, you could use                 
                                                                              
              #!/bin/bash -o pipefail                                         
                                                                              
              so that your pipes return the last non zero return.             
                                                                              
              might be a bit less coding                                      
                                                                              
              Edit: Example                                                   
                                                                              
   up vote 32 [root@localhost ~]# false | true                                
   down vote  [root@localhost ~]# echo $?                                     
              0                                                               
              [root@localhost ~]# set -o pipefail                             
              [root@localhost ~]# false | true                                
              [root@localhost ~]# echo $?                                     
              1                                                               
                                                                              
                                                           answered Jun 2 '11 
                                        edited Jun 8 '11             at 21:59 
              share|improve this answer         at 19:38                [IMG] 
                                                                        Chris 
                                                                        44435 
                   set -o pipefail inside the script should be more robust,   
              5    e.g. in case someone executes the script via bash foo.sh.  
                   – maxschlepzig Jun 3 '11 at 9:17                           
                   How does that work? do you have a example? – Johan Jun 8   
                   '11 at 18:40                                               
              1    Note that -o pipefail is not in POSIX. – scy Jan 25 '13 at 
                   15:15                                                      
                   This does not work in my BASH 3.2.25(1)-release. At the    
              2    top of /tmp/ff I have #!/bin/bash -o pipefail. Error is:   
                   /bin/bash: line 0: /bin/bash: /tmp/ff: invalid option name 
                   – Felipe Alvarez Mar 24 '14 at 6:01                        
                   @FelipeAlvarez: Some environments (including linux) don't  
                   parse spaces on #! lines beyond the first one, and so this 
                   becomes /bin/bash -o pipefail /tmp/ff, instead of the      
                   necessary /bin/bash -o pipefail /tmp/ff -- getopt (or      
                   similar) parsing using the optarg, which is the next item  
              1    in ARGV, as the argument to -o, so it fails. If you were   
                   to make a wrapper (say, bash-pf that just did exec         
                   /bin/bash -o pipefail "$@", and put that on the #! line,   
                   that would work. See also:                                 
                   en.wikipedia.org/wiki/Shebang_%28Unix%29 – lindes Dec 5    
                   '15 at 0:09                                                
                                                                              
               |  show 2 more comments                                        

     This solution works without using bash specific features or temporary files. Bonus: in the   
     end the exit status is actually the exit status and not some string in a file.               
                                                                                                  
     Situation:                                                                                   
                                                                                                  
     someprog | filter                                                                            
                                                                                                  
     you want the exit status from someprog and the output from filter.                           
                                                                                                  
     Here is my solution:                                                                         
                                                                                                  
     ((((someprog; echo $? >&3) | filter >&4) 3>&1) | (read xs; exit $xs)) 4>&1                   
                                                                                                  
     echo $?                                                                                      
                                                                                                  
     Example someprog and filter:                                                                 
                                                                                                  
     someprog() {                                                                                 
       echo "line1"                                                                               
       echo "line2"                                                                               
       echo "line3"                                                                               
       return 42                                                                                  
     }                                                                                            
                                                                                                  
     filter() {                                                                                   
       while read line; do                                                                        
         echo "filtered $line"                                                                    
       done                                                                                       
     }                                                                                            
                                                                                                  
     ((((someprog; echo $? >&3) | filter >&4) 3>&1) | (read xs; exit $xs)) 4>&1                   
                                                                                                  
     echo $?                                                                                      
                                                                                                  
     Example output:                                                                              
                                                                                                  
     filtered line1                                                                               
     filtered line2                                                                               
     filtered line3                                                                               
     42                                                                                           
                                                                                                  
       ----------------------------------------------------------------------------------------   
                                                                                                  
     Note: the child process inherits the open file descriptors from the parent. That means       
up   someprog will inherit open file descriptor 3 and 4. If someprog writes to file descriptor 3  
vote then that will become the exit status. The real exit status will be ignored because read     
28   only reads once.                                                                             
down                                                                                              
vote If you worry that your someprog might write to file descriptor 3 or 4 then it is best to     
     close the file descriptors before calling someprog.                                          
                                                                                                  
     (((((exec 3>&- 4>&-; someprog); echo $? >&3) | filter >&4) 3>&1) | (read xs; exit $xs)) 4>&1 
                                                                                                  
     The exec 3>&- 4>&- before someprog closes the file descriptor before executing someprog so   
     for someprog those file descriptors simply do not exist.                                     
                                                                                                  
       ----------------------------------------------------------------------------------------   
                                                                                                  
     Step by step explanation of the construct:                                                   
                                                                                                  
     ( ( ( ( someprog;          #part6                                                            
             echo $? >&3        #part5                                                            
           ) | filter >&4       #part4                                                            
         ) 3>&1                 #part3                                                            
       ) | (read xs; exit $xs)  #part2                                                            
     ) 4>&1                     #part1                                                            
                                                                                                  
     From bottom up:                                                                              
                                                                                                  
      1. A subshell is created with file descriptor 4 redirected to stdout. This means that       
         whatever is printed to file descriptor 4 in the subshell will end up as the stdout of    
         the entire construct.                                                                    
      2. A pipe is created and the commands on the left (#part3) and right (#part2) are executed. 
         exit $xs is also the last command of the pipe and that means the string from stdin will  
         be the exit status of the entire construct.                                              
      3. A subshell is created with file descriptor 3 redirected to stdout. This means that       
         whatever is printed to file descriptor 3 in this subshell will end up in #part2 and in   
         turn will be the exit status of the entire construct.                                    
      4. A pipe is created and the commands on the left (#part5 and #part6) and right (filter     
         >&4) are executed. The output of filter is redirected to file descriptor 4. In #part1    
         the file descriptor 4 was redirected to stdout. This means that the output of filter is  
         the stdout of the entire construct.                                                      
      5. Exit status from #part6 is printed to file descriptor 3. In #part3 file descriptor 3 was 
         redirected to #part2. This means that the exit status from #part6 will be the final exit 
         status for the entire construct.                                                         
      6. someprog is executed. The exit status is taken in #part5. The stdout is taken by the     
         pipe in #part4 and forwarded to filter. The output from filter will in turn reach stdout 
         as explained in #part4                                                                   
                                                                                                  
                                                      answered Mar 31 '13 at 10:08                
     share|improve this answer edited Jun 14 at 14:36                        [IMG]                
                                                                           lesmana                
                                                                        11.8k94566                
          Nice. For the function I might just do (read; exit $REPLY) – jthill Mar 2 '16 at 1:03   
     1    (exec 3>&- 4>&-; someprog) simplifies to someprog 3>&- 4>&-. – Roger Pate Apr 13 at     
          13:33                                                                                   
                                                                                                  
     add a comment |  expand to show all comments on this post                                    

        What I do when possible is to feed the exit code from foo into bar. For  
        example, if I know that foo never produces a line with just digits, then 
        I can just tack on the exit code:                                        
                                                                                 
        { foo; echo "$?"; } | awk '!/[^0-9]/ {exit($0)} {â*¦}'                   
                                                                                 
        Or if I know that the output from foo never contains a line with just .: 
                                                                                 
        { foo; echo .; echo "$?"; } | awk '/^\.$/ {getline; exit($0)} {â*¦}'     
                                                                                 
        This can always be done if there's some way of getting bar to work on    
        all but the last line, and pass on the last line as its exit code.       
                                                                                 
        If bar is a complex pipeline whose output you don't need, you can bypass 
        part of it by printing the exit code on a different file descriptor.     
                                                                                 
        exit_codes=$({ { foo; echo foo:"$?" >&3; } |                             
                       { bar >/dev/null; echo bar:"$?" >&3; }                    
                     } 3>&1)                                                     
                                                                                 
        After this $exit_codes is usually foo:X bar:Y, but it could be bar:Y     
        foo:X if bar quits before reading all of its input or if you're unlucky. 
        I think writes to pipes of up to 512 bytes are atomic on all unices, so  
        the foo:$? and bar:$? parts won't be intermixed as long as the tag       
        strings are under 507 bytes.                                             
                                                                                 
        If you need to capture the output from bar, it gets difficult. You can   
        combine the techniques above by arranging for the output of bar never to 
   up   contain a line that looks like an exit code indication, but it does get  
   vote fiddly.                                                                  
   21                                                                            
   down output=$(echo;                                                           
   vote          { { foo; echo foo:"$?" >&3; } |                                 
                   { bar | sed 's/^/^/'; echo bar:"$?" >&3; }                    
                 } 3>&1)                                                         
        nl='                                                                     
        '                                                                        
        foo_exit_code=${output#*${nl}foo:}; foo_exit_code=${foo_exit_code%%$nl*} 
        bar_exit_code=${output#*${nl}bar:}; bar_exit_code=${bar_exit_code%%$nl*} 
        output=$(printf %s "$output" | sed -n 's/^\^//p')                        
                                                                                 
        And, of course, there's the simple option of using a temporary file to   
        store the status. Simple, but not that simple in production:             
                                                                                 
          * If there are multiple scripts running concurrently, or if the same   
            script uses this method in several places, you need to make sure     
            they use different temporary file names.                             
          * Creating a temporary file securely in a shared directory is hard.    
            Often, /tmp is the only place where a script is sure to be able to   
            write files. Use mktemp, which is not POSIX but available on all     
            serious unices nowadays.                                             
                                                                                 
        foo_ret_file=$(mktemp -t)                                                
        { foo; echo "$?" >"$foo_ret_file"; } | bar                               
        bar_ret=$?                                                               
        foo_ret=$(cat "$foo_ret_file"; rm -f "$foo_ret_file")                    
                                                                                 
                                      edited Apr 13 at     answered Jun 3 '11 at 
                                                 12:36                      0:33 
        share|improve this answer                [IMG]                     [IMG] 
                                            Community♦                    Gilles 
                                                     1             432k868081299 
            When using the temporary file approach I prefer to add a trap for    
        1   EXIT that removes all temporary files so that no garbage will be     
            left even if the script dies – miracle173 Oct 16 '13 at 20:16        
                                                                                 
        add a comment |  expand to show all comments on this post                

              Starting from the pipeline:                                     
                                                                              
              foo | bar | baz                                                 
                                                                              
              Here is a general solution using only POSIX shell and no        
              temporary files:                                                
                                                                              
              exec 4>&1                                                       
              error_statuses="`((foo || echo "0:$?" >&3) |                    
                      (bar || echo "1:$?" >&3) |                              
                      (baz || echo "2:$?" >&3)) 3>&1 >&4`"                    
              exec 4>&-                                                       
                                                                              
              $error_statuses contains the status codes of any failed         
              processes, in random order, with indexes to tell which command  
              emitted each status.                                            
   up vote 17                                                                 
   down vote  # if "bar" failed, output its status:                           
              echo "$error_statuses" | grep '1:' | cut -d: -f2                
                                                                              
              # test if all commands succeeded:                               
              test -z "$error_statuses"                                       
                                                                              
              # test if the last command succeeded:                           
              ! echo "$error_statuses" | grep '2:' >/dev/null                 
                                                                              
              Note the quotes around $error_statuses in my tests; without     
              them grep can't differentiate because the newlines get coerced  
              to spaces.                                                      
                                                                              
                                 edited May 13 '13     answered Jul 15 '11 at 
              share|improve this          at 16:10                       7:02 
              answer                         [IMG]                      [IMG] 
                                           lesmana                     Jander 
                                        11.8k94566                 9,84422753 
                                                                              
              add a comment |  expand to show all comments on this post       

     So I wanted to contribute an answer like lesmana's, but I think mine is        
     perhaps a little simpler and slightly more advantageous pure-Bourne-shell      
     solution:                                                                      
                                                                                    
     # You want to pipe command1 through command2:                                  
     exec 4>&1                                                                      
     exitstatus=`{ { command1; printf $? 1>&3; } | command2 1>&4; } 3>&1`           
     # $exitstatus now has command1's exit status.                                  
                                                                                    
     I think this is best explained from the inside out â** command1 will execute   
     and print its regular output on stdout (file descriptor 1), then once it's     
     done, printf will execute and print command1's exit code on its stdout, but    
     that stdout is redirected to file descriptor 3.                                
                                                                                    
     While command1 is running, its stdout is being piped to command2 (printf's     
     output never makes it to command2 because we send it to file descriptor 3      
     instead of 1, which is what the pipe reads). Then we redirect command2's       
     output to file descriptor 4, so that it also stays out of file descriptor 1    
     â** because we want file descriptor 1 free for a little bit later, because we  
     will bring the printf output on file descriptor 3 back down into file          
     descriptor 1 â** because that's what the command substitution (the backticks), 
     will capture and that's what will get placed into the variable.                
                                                                                    
     The final bit of magic is that first exec 4>&1 we did as a separate command    
     â** it opens file descriptor 4 as a copy of the external shell's stdout.       
     Command substitution will capture whatever is written on standard out from the 
     perspective of the commands inside it â** but, since command2's output is      
     going to file descriptor 4 as far as the command substitution is concerned,    
     the command substitution doesn't capture it â** however, once it gets "out" of 
     the command substitution, it is effectively still going to the script's        
     overall file descriptor 1.                                                     
                                                                                    
     (The exec 4>&1 has to be a separate command because many common shells don't   
     like it when you try to write to a file descriptor inside a command            
     substitution, that is opened in the "external" command that is using the       
     substitution. So this is the simplest portable way to do it.)                  
                                                                                    
     You can look at it in a less technical and more playful way, as if the outputs 
     of the commands are leapfrogging each other: command1 pipes to command2, then  
up   the printf's output jumps over command 2 so that command2 doesn't catch it,    
vote and then command 2's output jumps over and out of the command substitution     
11   just as printf lands just in time to get captured by the substitution so that  
down it ends up in the variable, and command2's output goes on its merry way being  
vote written to the standard output, just as in a normal pipe.                      
                                                                                    
     Also, as I understand it, $? will still contain the return code of the second  
     command in the pipe, because variable assignments, command substitutions, and  
     compound commands are all effectively transparent to the return code of the    
     command inside them, so the return status of command2 should get propagated    
     out â** this, and not having to define an additional function, is why I think  
     this might be a somewhat better solution than the one proposed by lesmana.     
                                                                                    
     Per the caveats lesmana mentions, it's possible that command1 will at some     
     point end up using file descriptors 3 or 4, so to be more robust, you would    
     do:                                                                            
                                                                                    
     exec 4>&1                                                                      
     exitstatus=`{ { command1 3>&-; printf $? 1>&3; } 4>&- | command2 1>&4; } 3>&1` 
     exec 4>&-                                                                      
                                                                                    
     Note that I use compound commands in my example, but subshells (using ( )      
     instead of { } will also work, though may perhaps be less efficient.)          
                                                                                    
     Commands inherit file descriptors from the process that launches them, so the  
     entire second line will inherit file descriptor four, and the compound command 
     followed by 3>&1 will inherit the file descriptor three. So the 4>&- makes     
     sure that the inner compound command will not inherit file descriptor four,    
     and the 3>&- will not inherit file descriptor three, so command1 gets a        
     'cleaner', more standard environment. You could also move the inner 4>&- next  
     to the 3>&-, but I figure why not just limit its scope as much as possible.    
                                                                                    
     I'm not sure how often things use file descriptor three and four directly â**  
     I think most of the time programs use syscalls that return                     
     not-used-at-the-moment file descriptors, but sometimes code writes to file     
     descriptor 3 directly, I guess (I could imagine a program checking a file      
     descriptor to see if it's open, and using it if it is, or behaving differently 
     accordingly if it's not). So the latter is probably best to keep in mind and   
     use for general-purpose cases.                                                 
                                                                                    
                                                         answered Jun 5 '15 at 4:43 
     share|improve this answer      edited Oct 22 '16 at                      [IMG] 
                                                   18:48                   mtraceur 
                                                                              36429 
          Looks interesting, but I can't quite figure out what you expect this      
          command to do, and my computer can't, either; I get -bash: 3: Bad file    
          descriptor. – G-Man Jun 5 '15 at 7:03                                     
          @G-Man Right, I keep forgetting bash has no idea what it's doing when it  
          comes to file descriptors, unlike the shells I typically use (the ash     
          that comes with busybox). I'll let you know when I think of a workaround  
          that makes bash happy. In the meantime if you've got a debian box handy   
          you can try it in dash, or if you've got busybox handy you can try it     
          with the busybox ash/sh. – mtraceur Jun 5 '15 at 12:09                    
          @G-Man As to what I expect the command to do, and what it does do in      
          other shells, is redirect stdout from command1 so it doesn't get caught   
          by the command substitution, but once outside the command substitution,   
          it goes drops fd3 back to stdout so it's piped as expected to command2.   
          When command1 exits, the printf fires and prints its exit status, which   
          is captured into the variable by the command substitution. Very detailed  
          breakdown here: stackoverflow.com/questions/985876/tee-and-exit-status/…  
          Also, that comment of yours read as if it was meant to be kinda           
          insulting? – mtraceur Jun 5 '15 at 12:17                                  
          Where shall I begin? â** (1) Iâ**m sorry if you felt insulted. â**        
          â**Looks interestingâ** was meant earnestly; it would be great if         
          something as compact as that worked as well as you expected it to.â**     
          Beyond that, I was saying, simply, that I didnâ**t understand what your   
          solution was supposed to be doing.â** Iâ**ve been working/playing with    
          Unix for a long time (since before Linux existed), and, if I donâ**t      
          understand something, thatâ**s a red flag that, maybe, other people       
          wonâ**t understand it either, and that it needs more explanation          
          (IMNSHO).â** â*¦ (Contâ**d) – G-Man Jun 6 '15 at 3:14                     
          (Contâ**d) â*¦â** Since you â**â*¦ like to think â*¦ that [you]           
          understand just about everything more than the average personâ**, maybe   
          you should remember that the objective of Stack Exchange is not to be a   
          command-writing service, churning out thousands of one-off solutions to   
          trivially distinct questions; but rather to teach people how to solve     
          their own problems.â** And, to that end, maybe you need to explain stuff  
          well enough that an â**average personâ** can understand it.â** Look at    
          lesmanaâ**s answer for an example of an excellent explanation.â** â*¦     
          (Contâ**d) – G-Man Jun 6 '15 at 3:15                                      
                                                                                    
      |  show 9 more comments                                                       

                  If you have the moreutils package installed you can use the 
                  mispipe utility which does exactly what you asked.          
   up vote 8 down                                                             
   vote                                     answered Jun 8 '13 at 11:22       
                  share|improve this answer                       [IMG]       
                                                          Emanuele Aina       
                                                                  18113       
                                                                              
                  add a comment |  expand to show all comments on this post   

     lesmana's solution above can also be done without the overhead of starting nested    
     subprocesses by using { .. } instead (remembering that this form of grouped commands 
     always has to finish with semicolons). Something like this:                          
                                                                                          
up   { { { { someprog; echo $? >&3; } | filter >&4; } 3>&1; } | stdintoexitstatus; } 4>&1 
vote                                                                                      
6    I've checked this construct with dash version 0.5.5 and bash versions 3.2.25 and     
down 4.2.42, so even if some shells don't support { .. } grouping, it is still POSIX      
vote compliant.                                                                           
                                                                                          
                               answered Nov 22 '13 at 12:50                               
     share|improve this answer                        [IMG]                               
                                                    pkeller                               
                                                       6111                               
          This works really well with most shells I've tried it with, including NetBSD    
          sh, pdksh, mksh, dash, bash. However I can't get it to work with AT&T Ksh       
          (93s+, 93u+) or zsh (4.3.9, 5.2), even with set -o pipefail in ksh or any       
          number of sprinkled wait commands in either. I think it may, in part at least,  
          be a parsing issue for ksh, as if I stick to using subshells then it works      
          fine, but even with an if to choose the subshell variant for ksh but leave the  
          compound commands for others, it fails. – Greg A. Woods Aug 3 at 0:42           
                                                                                          
     add a comment |  expand to show all comments on this post                            

             Following is meant as an addon to the answer of @Patrik, in case 
             you are not able to use one of the common solutions.             
                                                                              
             This answer assumes following:                                   
                                                                              
               * You have a shell which does not know of $PIPESTATUS nor set  
                 -o pipefail                                                  
               * You want to use a pipe for parallel execution, so no         
                 temporary files.                                             
               * You do not want to have additional clutter around if you     
                 interrupt the script, possibly by a sudden power outage.     
               * This solution should be relatively easy to follow and clean  
                 to read.                                                     
               * You do not want to introduce additional subshells.           
               * You cannot fiddle with the existing file descriptors, so     
                 stdin/out/err must not be touched (however you can introduce 
                 some new one temporarily)                                    
                                                                              
               Additional assumptions. You can get rid of all, but this       
               clobbers the recipe too much, so it is not covered here:       
                                                                              
                 * All you want to know is that all commands in the PIPE have 
                   exit code 0.                                               
                 * You do not need additional side band information.          
                 * Your shell does wait for all pipe commands to return.      
                                                                              
             Before: foo | bar | baz, however this only returns the exit code 
             of the last command (baz)                                        
                                                                              
             Wanted: $? must not be 0 (true), if any of the commands in the   
             pipe failed                                                      
                                                                              
             After:                                                           
                                                                              
             TMPRESULTS="`mktemp`"                                            
             {                                                                
             rm -f "$TMPRESULTS"                                              
                                                                              
             { foo || echo $? >&9; } |                                        
             { bar || echo $? >&9; } |                                        
             { baz || echo $? >&9; }                                          
             #wait                                                            
             ! read TMPRESULTS <&8                                            
             } 9>>"$TMPRESULTS" 8<"$TMPRESULTS"                               
                                                                              
             # $? now is 0 only if all commands had exit code 0               
                                                                              
             Explained:                                                       
                                                                              
               * A tempfile is created with mktemp. This usually immediately  
                 creates a file in /tmp                                       
               * This tempfile is then redirected to FD 9 for write and FD 8  
                 for read                                                     
               * Then the tempfile is immediately deleted. It stays open,     
                 though, until both FDs go out of existence.                  
               * Now the pipe is started. Each step adds to FD 9 only, if     
                 there was an error.                                          
               * The wait is needed for ksh, because ksh else does not wait   
                 for all pipe commands to finish. However please note that    
                 there are unwanted sideffects if some background tasks are   
   up vote 4     present, so I commented it out by default. If the wait does  
   down vote     not hurt, you can comment it in.                             
               * Afterwards the file's contents are read. If it is empty      
                 (because all worked) read returns false, so true indicates   
                 an error                                                     
                                                                              
             This can be used as a plugin replacement for a single command    
             and only needs following:                                        
                                                                              
               * Unused FDs 9 and 8                                           
               * A single environment variable to hold the name of the        
                 tempfile                                                     
               * And this recipe can be adapted to fairly any shell out there 
                 which allows IO redirection                                  
               * Also it is fairly platform agnostic and does not need things 
                 like /proc/fd/N                                              
                                                                              
             BUGs:                                                            
                                                                              
             This script has a bug in case /tmp runs out of space. If you     
             need protection against this artificial case, too, you can do it 
             as follows, however this has the disadvantage, that the number   
             of 0 in 000 depends on the number of commands in the pipe, so it 
             is slightly more complicated:                                    
                                                                              
             TMPRESULTS="`mktemp`"                                            
             {                                                                
             rm -f "$TMPRESULTS"                                              
                                                                              
             { foo; printf "%1s" "$?" >&9; } |                                
             { bar; printf "%1s" "$?" >&9; } |                                
             { baz; printf "%1s" "$?" >&9; }                                  
             #wait                                                            
             read TMPRESULTS <&8                                              
             [ 000 = "$TMPRESULTS" ]                                          
             } 9>>"$TMPRESULTS" 8<"$TMPRESULTS"                               
                                                                              
             Portablility notes:                                              
                                                                              
               * ksh and similar shells which only wait for the last pipe     
                 command need the wait uncommented                            
                                                                              
               * The last example uses printf "%1s" "$?" instead of echo -n   
                 "$?" because this is more portable. Not every platform       
                 interprets -n correctly.                                     
                                                                              
               * printf "$?" would do it as well, however printf "%1s"        
                 catches some corner cases in case you run the script on some 
                 really broken platform. (Read: if you happen to program in   
                 paranoia_mode=extreme.)                                      
                                                                              
               * FD 8 and FD 9 can be higher on platforms which support       
                 multiple digits. AFAIR a POSIX conformant shell does only    
                 need to support single digits.                               
                                                                              
               * Was tested with Debian 8.2 sh, bash, ksh, ash, sash and even 
                 csh                                                          
                                                                              
                                                       answered Nov 17 '15 at 
             share|improve this edited Apr 12 '16                       12:26 
             answer                      at 11:26                       [IMG] 
                                                                         Tino 
                                                                        38827 
                                                                              
             add a comment |  expand to show all comments on this post        

             With a bit of precaution, this should work:                      
                                                                              
             foo-status=$(mktemp -t)                                          
             (foo; echo $? >$foo-status) | bar                                
   up vote 3 foo_status=$(cat $foo-status)                                    
   down vote                                                                  
                                edited Nov 19 '14 answered Jun 2 '11 at 20:40 
             share|improve this          at 15:01                       [IMG] 
             answer                         [IMG]                        alex 
                                           crayor                  3,53931623 
                                               32                             
                  How about to cleanup like jlliagre? Don't you leave a file  
                  behind called foo-status? – Johan Jun 8 '11 at 18:39        
                  @Johan: If you prefer my suggestion, don't hesitate to vote 
                  it up ;) In addition not to leaving a file, it has the      
                  advantage of allowing multiple processes to run this        
                  simultaneously and the current directory need not to be     
                  writable. – jlliagre Jun 8 '11 at 20:40                     
                                                                              
             add a comment |  expand to show all comments on this post        

        This is portable, i.e. works with any POSIX compliant shell, doesn't  
        require the current directory to be writable and allows multiple      
        scripts using the same trick to run simultaneously.                   
                                                                              
        (foo;echo $?>/tmp/_$$)|(bar;exit $(cat /tmp/_$$;rm /tmp/_$$))         
                                                                              
        Edit: here is a stronger version following Gilles' comments:          
   up                                                                         
   vote (s=/tmp/.$$_$RANDOM;((foo;echo $?>$s)|(bar)); exit $(cat $s;rm $s))   
   3                                                                          
   down Edit2: and here is a slightly lighter variant following dubiousjim    
   vote comment:                                                              
                                                                              
        (s=/tmp/.$$_$RANDOM;{foo;echo $?>$s;}|bar; exit $(cat $s;rm $s))      
                                                                              
                                                        answered Jun 2 '11 at 
                                  edited Mar 2 '16                      23:17 
        share|improve this answer          at 7:12                      [IMG] 
                                                                     jlliagre 
                                                                  37.8k468110 
             This doesn't work for several reasons. 1. The temporary file may 
             be read before it's written. 2. Creating a temporary file in a   
             shared directory with a predictable name is insecure (trivial    
        3    DoS, symlink race). 3. If the same script uses this trick        
             several times, it'll always use the same file name. To solve 1,  
             read the file after the pipeline has completed. To solve 2 and   
             3, use a temporary file with a randomly-generated name or in a   
             private directory. – Gilles Jun 8 '11 at 23:00                   
             +1 Well the ${PIPESTATUS[0]} is easier but the basic idea here   
             do work if one know about the problems that Gilles mentions.     
             – Johan Jun 9 '11 at 6:36                                        
             You can save a few subshells: (s=/tmp/.$$_$RANDOM;{foo;echo      
             $?>$s;}|bar; exit $(cat $s;rm $s)). @Johan: I agree it's easier  
             with Bash but in some contexts, knowing how to avoid Bash is     
             worth it. – dubiousjim Aug 29 '12 at 22:25                       
                                                                              
        add a comment |  expand to show all comments on this post             

             The following 'if' block will run only if 'command' succeeded:   
                                                                              
             if command; then                                                 
                # ...                                                         
             fi                                                               
                                                                              
             Specifically speaking, you can run something like this:          
                                                                              
             haconf_out=/path/to/some/temporary/file                          
                                                                              
             if haconf -makerw > "$haconf_out" 2>&1; then                     
                grep -iq "Cluster already writable" "$haconf_out"             
                # ...                                                         
             fi                                                               
                                                                              
   up vote 2 Which will run haconf -makerw and store its stdout and stderr to 
   down vote "$haconf_out". If the returned value from haconf is true, then   
             the 'if' block will be executed and grep will read               
             "$haconf_out", trying to match it against "Cluster already       
             writable".                                                       
                                                                              
             Notice that pipes automatically clean themselves up; with the    
             redirection you'll have to be carefull to remove "$haconf_out"   
             when done.                                                       
                                                                              
             Not as elegant as pipefail, but a legitimate alternative if this 
             functionality is not within reach.                               
                                                                              
                                                          answered Apr 22 '13 
                                       edited Apr 22 '13              at 0:37 
             share|improve this answer           at 0:46                [IMG] 
                                                              Rany Albeg Wein 
                                                                       519214 
                                                                              
             add a comment |  expand to show all comments on this post        

                Alternate example for @lesmana solution, possibly simplified. 
                Provides logging to file if desired.                          
                =====                                                         
                $ cat z.sh                                                    
                TEE="cat"                                                     
                #TEE="tee z.log"                                              
                #TEE="tee -a z.log"                                           
                                                                              
                exec 8>&- 9>&-                                                
                {                                                             
                  {                                                           
                    {                                                         
                      { #BEGIN - add code below this line and before #END     
                ./zz.sh                                                       
                echo ${?} 1>&8  # use exactly 1x prior to #END                
                      #END                                                    
   up vote 0          } 2>&1 | ${TEE} 1>&9                                    
   down vote        } 8>&1                                                    
                  } | exit $(read; printf "${REPLY}")                         
                } 9>&1                                                        
                                                                              
                exit ${?}                                                     
                $ cat zz.sh                                                   
                echo "my script code..."                                      
                exit 42                                                       
                $ ./z.sh; echo "status=${?}"                                  
                my script code...                                             
                status=42                                                     
                $                                                             
                                                                              
                                          answered Nov 27 '15 at 0:18         
                share|improve this answer                       [IMG]         
                                                                 C.G.         
                                                                    1         
                                                                              
                add a comment |  expand to show all comments on this post     

        EDIT: This answer is wrong, but interesting, so I'll leave it for     
        future reference.                                                     
                                                                              
          -----------------------------------------------------------------   
                                                                              
        Adding a ! to the command inverts the return code.                    
                                                                              
        http://tldp.org/LDP/abs/html/exit-status.html                         
                                                                              
        # =========================================================== #       
   up   # Preceding a _pipe_ with ! inverts the exit status returned.         
   vote ls | bogus_command     # bash: bogus_command: command not found       
   -1   echo $?                # 127                                          
   down                                                                       
   vote ! ls | bogus_command   # bash: bogus_command: command not found       
        echo $?                # 0                                            
        # Note that the ! does not change the execution of the pipe.          
        # Only the exit status changes.                                       
        # =========================================================== #       
                                                                              
                                                        answered Jun 2 '11 at 
                                  edited Jun 8 '11 at                   22:09 
        share|improve this answer               17:14                   [IMG] 
                                                                     Falmarri 
                                                                  4,041103856 
            I think this is unrelated. In your example, I want to know the    
        1   exit code of ls, not invert the exit code of bogus_command        
            – Michael Mrozek♦ Jun 2 '11 at 22:13                              
        2   I suggest to draw back that answer. – maxschlepzig Jun 3 '11 at   
            9:15                                                              
            Well, it appears I'm an idiot. I've actually used this in a       
        2   script before thinking it did what the OP wanted. Good thing I    
            didn't use it for anything important – Falmarri Jun 8 '11 at      
            17:14                                                             
                                                                              
        add a comment |  expand to show all comments on this post             

Your Answer

   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
   __________________________________________________________________________
    
   draft saved
   draft discarded
   _____________________

  Sign up or log in

   Sign up using Google

   Sign up using Facebook

   Sign up using Email and Password

  Post as a guest

   Name _______________________________  
   Email _______________________________ 

  Post as a guest

   Name _______________________________  
   Email _______________________________ 

   [ Post Your Answer ] discard

   By posting your answer, you agree to the privacy policy and terms of
   service.

Not the answer you're looking for? Browse other questions tagged shell pipe exit
or ask your own question.

   asked  6 years, 2 months ago 
   viewed 78,389 times          
   active 1 month ago           

    Linked

   11
   How can I pipe output to another process, but retain the error state of
   the first process?
   6
   How do I capture the return status and use tee at the same time in korn
   shell?
   1
   exit code of the command **before** last?
   4
   returncode of command in a pipline
   4
   How to capture the exit status of a non-final command in a pipeline?
   1
   Check for failure of piped command
   2
   How to get exit status of a particular command in a pipeline?
   8
   how to get exit status from the command before the last
   1
   How to capture “$?” before tee smashes it?
   0
   Get exit code from preceding command before pipe
   see more linked questionsâ*¦

    Related

   2
   Busybox ash script does not exit cleanly after executing cat; unable to
   get exit code
   2
   Get exit status of a process over SSH
   4
   Unable to get the right exit code from a script
   2
   How to read from a named pipe after the writer process exits?
   0
   Why is the exit status always 0 at the start of a script?
   1
   Capture exit status code from ssh
   2
   How to get exit status of a particular command in a pipeline?
   8
   Bash exit status used with PIPE
   0
   Get exit code from preceding command before pipe
   2
   pipe data into process that's already started

    Hot Network Questions

     * Loud pop noise while plugging to a headphones jack
     * Does any molecule other than DNA have a double-helix structure?
     * What's the performance benefit of saving all logged in characters in
       MMOs in regular intervals?
     * Could a WWI biplane fly if it were dropped from a high altitude
       instead of using a runway?
     * Why doesn't PRC help install a new leadership or stage a coup to
       preserve DPRK -- or even take it over altogether before the US does?
     * Seeing something from only one angle means you have only seen (what?)%
       of its surface area at most?
     * How to resolve an endless loop of attacks of opportunity?
     * A single religion in which different individuals worship different
       gods. Why hasn't the religion split?
     * Sulphuric Acid in Esterification Reaction
     * Can I write (200 MB - 150 min) music to a (700 MB - 80 min) CD?
     * Learning fundamental differences between functional programming and
       Object Oriented Programming
     * Is there word like "excruciating" but relating to pleasure rather than
       pain?
     * Batteries. Why use 9V?
     * Is a ring of integers necessarily Noetherian?
     * My husband is a beginner in cycling and needs some motivation
     * 91 Bottles of ASCII-beer on the Wall
     * How do I react when a girl I like has a new haircut that I don't like
       very much?
     * Should all books have page numbers?
     * Can I rebound a spell that exiles itself?
     * Two classes next to each other in CSS
     * Were there ever any libraries in medieval villages?
     * Quoting a typo: Do I really have to do "sic", or can I just fix the
       sentence?
     * Where do bad papers go to die?
     * Is there a distinction between ç©ºæ¸¯ (kÅ*nggÇ*ng) and æ*ºå*º
       (jÄ«chÇ*ng) which both mean airport?
   more hot questions
   question feed

      Unix & Linux

     * Tour
     * Help
     * Chat
     * Contact
     * Feedback
     * Mobile

      Company

     * Stack Overflow
     * Stack Overflow Business
     * Developer Jobs
     * About
     * Press
     * Legal
     * Privacy Policy

      Stack Exchange
      Network

     * Technology
     * Life / Arts
     * Culture / Recreation
     * Science
     * Other
     * Stack Overflow
     * Server Fault
     * Super User
     * Web Applications
     * Ask Ubuntu
     * Webmasters
     * Game Development
     * TeX - LaTeX
     * Software Engineering
     * Unix & Linux
     * Ask Different (Apple)
     * WordPress Development
     * Geographic Information Systems
     * Electrical Engineering
     * Android Enthusiasts
     * Information Security
     * Database Administrators
     * Drupal Answers
     * SharePoint
     * User Experience
     * Mathematica
     * Salesforce
     * ExpressionEngine® Answers
     * Blender
     * Network Engineering
     * Cryptography
     * Code Review
     * Magento
     * Software Recommendations
     * Signal Processing
     * Emacs
     * Raspberry Pi
     * Programming Puzzles & Code Golf
     * Ethereum
     * Data Science
     * Arduino
     * more (26)
     * Photography
     * Science Fiction & Fantasy
     * Graphic Design
     * Movies & TV
     * Music: Practice & Theory
     * Worldbuilding
     * Seasoned Advice (cooking)
     * Home Improvement
     * Personal Finance & Money
     * Academia
     * Law
     * more (17)
     * English Language & Usage
     * Skeptics
     * Mi Yodeya (Judaism)
     * Travel
     * Christianity
     * English Language Learners
     * Japanese Language
     * Arqade (gaming)
     * Bicycles
     * Role-playing Games
     * Anime & Manga
     * Puzzling
     * Motor Vehicle Maintenance & Repair
     * more (32)
     * MathOverflow
     * Mathematics
     * Cross Validated (stats)
     * Theoretical Computer Science
     * Physics
     * Chemistry
     * Biology
     * Computer Science
     * Philosophy
     * more (10)
     * Meta Stack Exchange
     * Stack Apps
     * API
     * Data
     * Area 51
     * Blog
     * Facebook
     * Twitter
     * LinkedIn

   site design / logo © 2017 Stack Exchange Inc; user contributions licensed
   under cc by-sa 3.0 with attribution required. rev 2017.8.11.26777

   Linux is a registered trademark of Linus Torvalds. UNIX is a registered
   trademark of The Open Group.
   This site is not affiliated with Linus Torvalds or The Open Group in any
   way.
   Unix & Linux Stack Exchange works best with JavaScript enabled
